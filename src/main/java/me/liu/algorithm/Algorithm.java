package me.liu.algorithm;

/**
 * 首先，快排不是最快的，它只是基于比较的排序算法中渐进时间复杂度最优的排序算法之一。
 * 在数据量很小时，大家更倾向于用插入排序，因为实现简单，不需要递归，而且效率更高（实际上，c++ STL中的快排算法，当递归到元素个数小于K时，就不再递归而是调用插入排序）
 * 对于不基于比较的排序，例如计数排序和桶排序等，都是复杂度O(n)的算法，当然更快了
 * 而且除了快，还要看其他的东西，例如是否是原地排序，递归深度，stability，并行性，locality，scalability，通信复杂度和实际要面临的数据的规律等等
 * 在外存排序中，或者分布式环境下的排序，大家更倾向于用归并排序，因为实现简单，效率高（例如用mapreduce做）
 * 但是如果lz看过分布式的排序的论文的话，就会发现论文提出的非常快的算法很多还是基于快排的，不过做了很多改进，例如Histogram Sort，但这些都是要求MPI编程的
 * 当然，还有针对专门的硬件设计的排序，例如基于Cell Processor的Cell Sort，号称在那上面比快排更快
 * 以及基于排序网络的排序，例如bitonic sort（虽然对于大规模数据可以实际使用排序网络这玩意儿还没真正研发出来？）
 * 以及那些用来调情的排序，例如鸡尾酒排序
 * 以及那些用来搞笑的排序，例如珠排序和stooge sort等
 * <p>
 * <p>
 * Created by tongwei on 17/8/21.
 */
public class Algorithm {

    public static void main(String[] args) {


        // 很多东西都比性能重要，但是性能是决定一个方案行不行的因素


    }
}
